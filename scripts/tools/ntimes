#!/usr/bin/env bash

# Unoffical Bash "strict mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
#ORIGINAL_IFS=$IFS
IFS=$'\t\n' # Stricter IFS settings

usage() {
    cat <<EOF
Simple Bash script to run a command multiple times. Easier than using the for
loop syntax.

Usage:

ntimes [options] [command ...]

Options:

-n|--times            The number of times to execute the command
-f|--failure          Execute the command until it fails
-s|--success          Execute the command until it succeeds

Example:

$ ntimes 10 ping -c stratus3d.com

Will run the ping command 10 times
EOF
}

error_exit() {
  echo "Error: ""$@"
  exit 1
}


get_value() {
  raw_flag=$1
  first=${1#*'='}
  second=$2

  # If the raw flag contains an equals sign and the value after it (first) is
  # not null return first, otherwise return the next argument (second)
  if [[ "$raw_flag" == *=* ]] && [ -n "$first" ]; then
    echo "$first"
  else
    if [[ "$second" == -* ]]; then
      echo "$second"
    else
      echo "$second"
    fi
  fi
}

get_shift_count() {
  if [[ "$1" == *=* ]]; then
    echo "1"
  else
    echo "2"
  fi
}

log_command() {
  expression="$@"
  echo "Executing '$expression'"
}

number=''
parallel=false
until=''

while :; do
    case ${1:-} in
        -h|-\?|--help)
            usage
            exit
            ;;
        -n|--times|--times=*)
            number=$(get_value "$1" "${2:-}")
            shift $(get_shift_count "$1")
            ;;
        -p|--parallel)
            parallel=true
            shift
            ;;
        -s|--success)
            until=success
            shift
            ;;
        -f|--failure)
            until=failure
            shift
            ;;
        --)
            shift
            break 2
            ;;
        *)
            if [ -z "${1:-}" ]; then
                break 2
            else
                error_exit "Unknown option ${1:-}"
            fi
    esac
done

if [ ! -z "${number+x}" ]; then
  # Execute the command a set number of times
  for i in $(seq $number); do
    log_command "$@"

    if [ "$parallel" = true ]; then
      # Execute child process if parallel is true
      "$@" &
    else
      # Otherwise execute in the current process sequentially
      "$@"
    fi
  done
else
  # Must be until success or failure
  if [ "$until" = "success" ]; then
    until log_command "$@" && "$@"; do
      true
    done
  elif [ "$until" = "failure" ]; then
    while log_command "$@" && "$@"; do
      true
    done
  else
    error_exit "Must be until success or failure if the number of runs is not specified"
  fi
fi
